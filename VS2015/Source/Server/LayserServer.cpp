//
//
//  Generated by StarUML(tm) C++ Add-In
//
//  @ Project : Laser_sys
//  @ File Name : LayserServer.cpp
//  @ Date : 2017/7/4
//  @ Author : akfheaven
//
//

#include <cstdio>
#include <winsock2.h>
#include <Ws2tcpip.h>
#include <mswsock.h>

#include "LayserServer.h"
#include "opencv2/calib3d/calib3d.hpp"

#include "LayserServer.h"
#pragma comment(lib, "Ws2_32.lib")

using namespace cv;

//static
const double LayserServer::IP_TIME_OUT = 1000.0f;//static const double
const double LASER_CYCLE_TIME = 2000;// us

LayserServer::LayserServer()
{
	ReadThread = NULL;
	SendThread = NULL;

	Trackers = NULL;

	ReadContinueFlag = false;
	SendContinueFlag = false;
}

LayserServer::~LayserServer()
{
	Stop();
}

void LayserServer::Start() {
	//trackers
	InitializeCriticalSection(&TrackersCpyLock);
	Trackers = new vector<Tracker*>();
	Trackers->clear();
	TrackersCpy = new vector<Tracker*>();
	TrackersCpy->clear();
	InitID();

	//map lock
	InitializeCriticalSection(&g_cs);

	//start read and send thread;
	ReadThread = new SimpleThread();
	ReadThread->SetRun(ReadDataRunWarp, this);

	SendThread = new SimpleThread();
	SendThread->SetRun(SendDataRunWarp, this);

	ReadContinueFlag = true;
	SendContinueFlag = true;
	
	ReadThread->Start("Read");
	SendThread->Start("Send");

	
}

void LayserServer::Stop() {
	ReadContinueFlag = false;
	SendContinueFlag = false;

	ReadThread->Stop();
	SendThread->Stop();
}

vector<Tracker*>* LayserServer::GetTrackers() {
	EnterCriticalSection(&TrackersCpyLock);
	TrackersCpy->clear();
	for (int i = 0; i < Trackers->size(); i++) {
		TrackersCpy->push_back((*Trackers)[i]);
	}
	LeaveCriticalSection(&TrackersCpyLock);
	return TrackersCpy;
}


//ReadThread EnteryWarpper
void LayserServer::ReadDataRunWarp(void * Owner)
{
	LayserServer* server = (LayserServer*)(Owner);
	server->ReadDataRun();
}

//SendThread EnteryWarpper
void LayserServer::SendDataRunWarp(void * Owner)
{
	LayserServer* server = (LayserServer*)(Owner);
	server->SendDataRun();
}

//Read UDP Data
void LayserServer::ReadDataRun()
{
	int recv_len;
	char buf[MAX_BUFFER];
	char* recv_addr = nullptr;

	//double tttime = 0;
	//memset(&si_other, 0, sizeof(si_other));
	//si_other.sin_family = AF_INET;
	//si_other.sin_addr.S_un.S_addr = inet_addr("192.168.1.105");
	//si_other.sin_port = htons(32154);
	////sendto(s, "hhhhh", 5, 0, (sockaddr*)&si_other, slen);
	//int cc = 0;

	selectedMode = SERIAL_MODE;

	if (selectedMode == SOCKET_MODE) {
		SocketRead* socketRead = new SocketRead();
		socketRead->Init(8999);
		readInterface = socketRead;
	}
	else if (selectedMode == SERIAL_MODE) {
		SerialRead* serialRead = new SerialRead();
		while(!serialRead->Init("COM3", 115200)) {
			Sleep(1000);
		}
		readInterface = serialRead;
	}


	//keep listening for data
	while (ReadContinueFlag)
	{


		//try to receive some data, this is a blocking call
		if (readInterface->RecieveData(buf, recv_len, recv_addr)){
			
			//printf("[read threadrun] %d\n", GetTickCount());
			//buf[recv_len] = '\0';
			//for (int i = 0; i < recv_len; i++)
			//printf("%d ", (int)buf[i]);
			//puts("");
			//continue;
			//printf("%lf\n", GetTickCount() - tttime);
			//cc++;
			//if (cc % 4 == 0)
			//	Sleep(1000);
			////echo 
			//sendto(s, "hhhhh", 5, 0, (sockaddr*)&si_other, slen);
			//tttime = GetTickCount();
			//continue;

			//ID Management
			//strcpy(fromIp, inet_ntoa(si_other.sin_addr));
			//fromIp = inet_ntoa(si_other.sin_addr);

			EnterCriticalSection(&g_cs);// lock map
			int id = addrMapGenID[recv_addr];
			//printf("%d\n", id);
			bool idExist = (id >= 1 && id <= MAX_TRACKER_NUM);
			if (! idExist) {//!exist thend add map
				id = GenID();
				if (id > 0 && id <= MAX_TRACKER_NUM) {//GenOK
					addrMapGenID[recv_addr] = id;
					GenIDMapRealID[id] = 1;
				}
			}
			LeaveCriticalSection(&g_cs);


			//Decode
			idExist = (id >= 1 && id <= MAX_TRACKER_NUM);
			if (idExist) {
				GenIDMapTimeTick[id] = GetTickCount();
				DecodeMavlink(id, buf, recv_len);//genId
			}
			else {
				puts("too many connections");
			}


			/*EnterCriticalSection(&g_cs);
			if (readedBufferLen + recv_len > MAX_BUFFER)readedBufferLen = 0;
			memcpy(decodeBuffer + readedBufferLen, buf, recv_len);
			readedBufferLen += recv_len;
			LeaveCriticalSection(&g_cs);*/
		}
	}
	/*closesocket(s);
	WSACleanup();*/
	readInterface->close();
	delete readInterface;
}

//Send
void LayserServer::SendDataRun()
{
	//UDP SetUp
	SOCKET s;
	struct sockaddr_in remote;
	//int  recv_len;
	//char buf[MAX_BUFFER];
	WSADATA wsa;

	//Initialise winsock
	printf("\n[send thread run]\nInitialising Winsock...");
	if (WSAStartup(MAKEWORD(2, 2), &wsa) != 0)
	{
		printf("Failed. Error Code : %d", WSAGetLastError());
		return;
	}
	printf("UDP Initialised.\n");

	//Create a socket
	if ((s = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP)) == INVALID_SOCKET)
	{
		printf("Could not create socket : %d", WSAGetLastError());
	}
	printf("Socket created.\n");

	/*sockaddr_in local;
	local.sin_family = AF_INET;
	local.sin_addr.S_un.S_addr = INADDR_ANY;
	local.sin_port = 4004;
	memset(local.sin_zero, 0, 8);*/
	//Bind
	/*if (bind(s, (struct sockaddr *)&local, sizeof(local)) == SOCKET_ERROR)
	{
		printf("Bind failed with error code : %d", WSAGetLastError());
		return;
	}
	puts("UDP Bind done");*/


	ip_mreq mcast;
	mcast.imr_interface.S_un.S_addr = INADDR_ANY;// inet_addr("127.0.0.1");
	mcast.imr_multiaddr.S_un.S_addr = inet_addr("234.5.6.7");
	setsockopt(s, IPPROTO_IP, IP_ADD_MEMBERSHIP, (char*)&mcast, sizeof(mcast));

	//int optval = 8;
	//setsockopt(s, IPPROTO_IP, IP_MULTICAST_TTL, (char*)&optval, sizeof(int));

	int loop = 1;
	setsockopt(s, IPPROTO_IP, IP_MULTICAST_LOOP, (char*)&loop, sizeof(int));



	//Prepare the sockaddr_in structure
	memset(&remote, 0, sizeof(remote));
	remote.sin_family = AF_INET;
	remote.sin_addr.S_un.S_addr = inet_addr("234.5.6.7");
	//remote.sin_addr.S_un.S_addr = inet_addr("127.0.0.1");
	//remote.sin_addr.S_un.S_addr = inet_addr("192.168.1.111");
	remote.sin_port = htons(portSend);


	
	//Multicast mavlink
	while (SendContinueFlag) {

		//Get Trackers To Send
		MulticastTrackerData(s, remote);
	}

	closesocket(s);
	WSACleanup();
}


void LayserServer::EPnpCalculate(uint8_t channel, mavlink_sensor_time_t sensorPck)
{
#ifdef MDebug
	printf("%lf timeX1\n", sensorPck.timeX[1]);
#endif
	Mat op = (Mat_<Point3d>(1, 5) <<
		Point3d(0, 0, 0),
		Point3d(0.04, 0, 0),
		Point3d(0, 0.04, 0),
		Point3d(0.04, 0.04, 0),
		Point3d(0.02, 0.02, 0.0145)
		);
	Mat ip;
	
	for (int i = 0; i < 5; i++) {
		float x = tan(3.1415926 * (0.5 - sensorPck.timeX[i] / LASER_CYCLE_TIME * 2));//cot(angle) = tan(pi/2 - angle)
		float y = tan(3.1415926 * (0.5 - sensorPck.timeY[i] / LASER_CYCLE_TIME * 2));
		ip.push_back(Point2d(x, y));
	}


	//calculate
	Matx33d camMatrix(
		1, 0, 0,
		0, 1, 0,
		0, 0, 1.0
		);


	vector<double> tv(3), rv(3);
	Mat rvec(rv), tvec(tv);


	solvePnP(op, ip, camMatrix, noArray(), rvec, tvec, false, CV_EPNP);

	double rot[9] = { 0 };
	Mat rotM(3, 3, CV_64FC1, rot);
	Rodrigues(rvec, rotM);
	double* _r = rotM.ptr<double>();

	// Matrix to Quat 
	float m11 = _r[0], m12 = _r[1], m13 = _r[2];
	float m21 = _r[3], m22 = _r[4], m23 = _r[5];
	float m31 = _r[6], m32 = _r[7], m33 = _r[8];

	float forW = m11 + m22 + m33;
	float forX = m11 - m22 - m33;
	float forY = m22 - m11 - m33;
	float forZ = m33 - m11 - m22;
	int bigIndex = 0;

	float forBig = forW;
	if (forX > forBig) {
		forBig = forX;
		bigIndex = 1;

	}
	if (forY > forBig) {
		forBig = forY;
		bigIndex = 2;

	}
	if (forZ > forBig) {
		forBig = forZ;
		bigIndex = 3;

	}

	float w = 1, x = 0, y = 0, z = 0;

	float bigValue = sqrt(forBig + 1.0f) * 0.5;
	float mult = 0.25f / bigValue;
	switch (bigIndex) {
	case 0:
		w = bigValue;
		x = (m23 - m32) * mult;
		y = (m31 - m13) * mult;
		z = (m12 - m21) * mult;
		break;
	case 1:
		x = bigValue;
		w = (m23 - m32) * mult;
		y = (m12 + m21) * mult;
		z = (m31 + m13) * mult;
		break;
	case 2:
		y = bigValue;
		w = (m31 - m13) * mult;
		x = (m12 + m21) * mult;
		z = (m23 + m32) * mult;
		break;
	case 3:
		z = bigValue;
		w = (m12 - m21) * mult;
		x = (m31 + m13) * mult;
		y = (m23 + m32) * mult;
		break;
	}
	
	//get result 
	ReadTracker[channel].Px = tv[0];
	ReadTracker[channel].Py = tv[1];
	ReadTracker[channel].Pz = tv[2];

	ReadTracker[channel].Qw = w;
	ReadTracker[channel].Qx = -x;
	ReadTracker[channel].Qy = -y;
	ReadTracker[channel].Qz = -z;
}

//Decode with Mavlink Protocal
void LayserServer::DecodeMavlink(uint8_t channel, char * data, int len)
{
	for (int i = 0; i < len; i++) {
		if (mavlink_parse_char(channel, data[i], &DecodeMsg[channel], &status)) {
#ifdef MDebug
			printf("%d DecodeMsg[channel].msgid\n", DecodeMsg[channel].msgid);
#endif
			if (DecodeMsg[channel].msgid == MAVLINK_MSG_ID_ATTITUDE_QUATERNION)
			{
				memcpy(&quatPck, DecodeMsg[channel].payload64, MAVLINK_MSG_ID_ATTITUDE_QUATERNION_LEN);
#ifdef MDebug
				printf("%d | %f | %f | %f\n", quatPck.time_boot_ms, quatPck.pitchspeed, quatPck.rollspeed, quatPck.yawspeed);
#endif
				ReadTracker[channel].timeStemp = quatPck.time_boot_ms;
				ReadTracker[channel].Qw = quatPck.q1;
				ReadTracker[channel].Qx = quatPck.q2;
				ReadTracker[channel].Qy = quatPck.q3;
				ReadTracker[channel].Qz = quatPck.q4;
			}
			else if (DecodeMsg[channel].msgid == MAVLINK_MSG_ID_SENSOR_TIME) {
				memcpy(&sensorPck, DecodeMsg[channel].payload64, MAVLINK_MSG_ID_SENSOR_TIME_LEN);
				EPnpCalculate(channel, sensorPck);
			}
		}
	}
}

//Encode with Mavlink And BroadCast
void LayserServer::MulticastTrackerData(SOCKET &s, sockaddr_in &remote)
{
	EnterCriticalSection(&g_cs);// lock map

	EnterCriticalSection(&TrackersCpyLock);//lock vector

	map<char*, int>::iterator it = addrMapGenID.begin();
	Trackers->clear();

	int n = 0;
	while (it != addrMapGenID.end()) {
		
		int genId = it->second;
		//check zombie ip
		double curTime = GetTickCount();
		double timeSpan = curTime - GenIDMapTimeTick[genId];
		if (timeSpan > IP_TIME_OUT) {
			
			addrMapGenID.erase(it++);
			
			DelID(genId);
			int realId = GenIDMapRealID[genId];
			GenIDMapRealID[genId] = -1;
			RealIDMapGenID[realId] = -1;
		}
		else {// not time out
			//update Trackers
			Tracker* curTracker = &ReadTracker[genId];
			int realId = GenIDMapRealID[genId];
			curTracker->ReadId = realId;
			curTracker->GenId = genId;
			Trackers->push_back(curTracker);
			
			n++;
			it++;
		}
	}
	LeaveCriticalSection(&TrackersCpyLock);
	LeaveCriticalSection(&g_cs);


	for (int i = 0; i < Trackers->size(); i++) {
		//mavlink multicast  thread lock require?
		Tracker* curTracker = (*Trackers)[i];
		int realId = curTracker->ReadId;
		if (realId == -1)continue;

		ToSendTracker.ID = realId;
		ToSendTracker.Qw = curTracker->Qw;
		ToSendTracker.Qx = curTracker->Qx;
		ToSendTracker.Qy = curTracker->Qy;
		ToSendTracker.Qz = curTracker->Qz;

		mavlink_msg_t_tracker_encode(1, 200, &EncodeMsg[realId], &ToSendTracker);
		int mavLen = mavlink_msg_to_send_buffer(MavSendBuffer[realId], &EncodeMsg[realId]);

		//printf("%d %d\n", n, realId);
		if (sendto(s, (char*)MavSendBuffer[realId], mavLen, 0, (sockaddr*)&remote, sizeof(remote)) < 0) {
			perror("sendto failed");
		}
	}
	
}

void LayserServer::InitID()
{
	for (int i = 1; i < MAX_TRACKER_NUM; i++) {
		NextGenID[i] = i + 1;
	}
	NextGenID[MAX_TRACKER_NUM] = 0; //end
	NextGenID[0] = 1;//as tail manager

	for (int i = 0; i <= MAX_TRACKER_NUM; i++) {
		GenIDMapRealID[i] = -1;
		RealIDMapGenID[i] = -1;
		IsGenIDExist[i] = false;
	}
}

int LayserServer::GenID()
{
	int i = NextGenID[0];
	if (i != 0) {
		IsGenIDExist[i] = true;
		NextGenID[0] = NextGenID[i];
	}
	return i;
}

int LayserServer::DelID(int id)
{
	if (id >= 1 && id <= MAX_TRACKER_NUM && IsGenIDExist[id]) {
		
		int i = NextGenID[0];
		NextGenID[0] = id;
		NextGenID[id] = i;
		IsGenIDExist[id] = false;
		return 0;
	}
	return -1;
}

bool LayserServer::setGenIdMapRealID(int GenID, int RealID)
{
	if (GenID < 1 || GenID > MAX_TRACKER_NUM || RealID < 0 || RealID >= MAX_TRACKER_NUM)return false;

	int preGenID = RealIDMapGenID[RealID];
	if (preGenID == -1) {//!exist
		RealIDMapGenID[RealID] = GenID;
	}
	else {//exist: preGenID map RealID
		GenIDMapRealID[preGenID] = -1;
		RealIDMapGenID[RealID] = GenID;
	}

	GenIDMapRealID[GenID] = RealID;
	return true;
}



