//
//
//  Generated by StarUML(tm) C++ Add-In
//
//  @ Project : Laser_sys
//  @ File Name : LayserServer.cpp
//  @ Date : 2017/7/4
//  @ Author : 
//
//

#include <cstdio>
#include <winsock2.h>
#include <Ws2tcpip.h>
#include <mswsock.h>
#include "LayserServer.h"
#pragma comment(lib, "Ws2_32.lib")

//static
const double LayserServer::IP_TIME_OUT = 1000.0f;//static const double

LayserServer::LayserServer()
{
	ReadThread = NULL;
	SendThread = NULL;

	Trackers = NULL;

	ReadContinueFlag = false;
	SendContinueFlag = false;
}

LayserServer::~LayserServer()
{
	Stop();
}

void LayserServer::Start(int pPort) {
	//port
	port = pPort;

	//trackers
	Trackers = new vector<Tracker*>();
	Trackers->clear();
	InitID();

	//map lock
	InitializeCriticalSection(&g_cs);

	//start read and send thread;
	ReadThread = new SimpleThread();
	ReadThread->SetRun(ReadDataRunWarp, this);

	SendThread = new SimpleThread();
	SendThread->SetRun(SendDataRunWarp, this);

	ReadContinueFlag = true;
	SendContinueFlag = true;
	
	ReadThread->Start("Read");
	SendThread->Start("Send");

	
}

void LayserServer::Stop() {
	ReadContinueFlag = false;
	SendContinueFlag = false;

	ReadThread->Stop();
	SendThread->Stop();
}

void LayserServer::UpdateChipName(char* NewName) {

}

vector<Tracker*>* LayserServer::GetTrackers() {
	return Trackers;
}


//ReadThread EnteryWarpper
void LayserServer::ReadDataRunWarp(void * Owner)
{
	LayserServer* server = (LayserServer*)(Owner);
	server->ReadDataRun();
}

//SendThread EnteryWarpper
void LayserServer::SendDataRunWarp(void * Owner)
{
	LayserServer* server = (LayserServer*)(Owner);
	server->SendDataRun();
}

//Read UDP Data
void LayserServer::ReadDataRun()
{
	SOCKET s;
	struct sockaddr_in server, si_other;
	int slen, recv_len;
	char buf[MAX_BUFFER];
	WSADATA wsa;

	slen = sizeof(si_other);

	//Initialise winsock
	printf("\nInitialising Winsock...");
	if (WSAStartup(MAKEWORD(2, 2), &wsa) != 0)
	{
		printf("Failed. Error Code : %d", WSAGetLastError());
		return ;
	}
	printf("UDP Initialised.\n");

	//Create a socket
	if ((s = socket(AF_INET, SOCK_DGRAM, 0)) == INVALID_SOCKET)
	{
		printf("Could not create socket : %d", WSAGetLastError());
	}
	printf("Socket created.\n");

	//Prepare the sockaddr_in structure
	server.sin_family = AF_INET;
	server.sin_addr.s_addr = INADDR_ANY;
	server.sin_port = htons(port);

	//Bind
	if (bind(s, (struct sockaddr *)&server, sizeof(server)) == SOCKET_ERROR)
	{
		printf("Bind failed with error code : %d", WSAGetLastError());
		return;
	}
	puts("UDP Bind done");

	char* fromIp;
	//keep listening for data
	while (ReadContinueFlag)
	{


		//try to receive some data, this is a blocking call
		if ((recv_len = recvfrom(s, buf, READ_LEN, 0, (struct sockaddr *) &si_other, &slen)) == SOCKET_ERROR)
		{
			printf("recvfrom() failed with error code : %d", WSAGetLastError());
			//break;
		}
		else {

			//ID Management
			//strcpy(fromIp, inet_ntoa(si_other.sin_addr));
			fromIp = inet_ntoa(si_other.sin_addr);

			EnterCriticalSection(&g_cs);// lock map
			int id = IpMapGenID[fromIp];
			//printf("%d\n", id);
			bool idExist = (id >= 1 && id <= MAX_TRACKER_NUM);
			if (! idExist) {//!exist thend add map
				id = GenID();
				if (id > 0 && id <= MAX_TRACKER_NUM) {//GenOK
					IpMapGenID[fromIp] = id;
					GenIDMapReadID[id] = id - 1;//Test ,real for custom
				}
			}
			LeaveCriticalSection(&g_cs);


			//Decode
			idExist = (id >= 1 && id <= MAX_TRACKER_NUM);
			if (idExist) {
				GenIDMapTimeTick[id] = GetTickCount();
				DecodeMavlink(id, buf, recv_len);//genId
			}
			else {
				puts("too many connections");
			}


			/*EnterCriticalSection(&g_cs);
			if (readedBufferLen + recv_len > MAX_BUFFER)readedBufferLen = 0;
			memcpy(decodeBuffer + readedBufferLen, buf, recv_len);
			readedBufferLen += recv_len;
			LeaveCriticalSection(&g_cs);*/
		}
	}
	closesocket(s);
	WSACleanup();
}

//Send
void LayserServer::SendDataRun()
{
	//UDP SetUp
	SOCKET s;
	struct sockaddr_in remote;
	int  recv_len;
	char buf[MAX_BUFFER];
	WSADATA wsa;

	//Initialise winsock
	printf("\nInitialising Winsock...");
	if (WSAStartup(MAKEWORD(2, 2), &wsa) != 0)
	{
		printf("Failed. Error Code : %d", WSAGetLastError());
		return;
	}
	printf("UDP Initialised.\n");

	//Create a socket
	if ((s = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP)) == INVALID_SOCKET)
	{
		printf("Could not create socket : %d", WSAGetLastError());
	}
	printf("Socket created.\n");

	/*sockaddr_in local;
	local.sin_family = AF_INET;
	local.sin_addr.S_un.S_addr = INADDR_ANY;
	local.sin_port = 4004;
	memset(local.sin_zero, 0, 8);*/
	//Bind
	/*if (bind(s, (struct sockaddr *)&local, sizeof(local)) == SOCKET_ERROR)
	{
		printf("Bind failed with error code : %d", WSAGetLastError());
		return;
	}
	puts("UDP Bind done");*/


	ip_mreq mcast;
	mcast.imr_interface.S_un.S_addr = INADDR_ANY;// inet_addr("127.0.0.1");
	mcast.imr_multiaddr.S_un.S_addr = inet_addr("234.5.6.7");
	setsockopt(s, IPPROTO_IP, IP_ADD_MEMBERSHIP, (char*)&mcast, sizeof(mcast));

	//int optval = 8;
	//setsockopt(s, IPPROTO_IP, IP_MULTICAST_TTL, (char*)&optval, sizeof(int));

	int loop = 1;
	setsockopt(s, IPPROTO_IP, IP_MULTICAST_LOOP, (char*)&loop, sizeof(int));



	//Prepare the sockaddr_in structure
	memset(&remote, 0, sizeof(remote));
	remote.sin_family = AF_INET;
	remote.sin_addr.S_un.S_addr = inet_addr("234.5.6.7");
	//remote.sin_addr.S_un.S_addr = inet_addr("127.0.0.1");
	//remote.sin_addr.S_un.S_addr = inet_addr("192.168.1.107");
	remote.sin_port = htons(portSend);


	
	//Multicast mavlink
	while (SendContinueFlag) {

		//Get Trackers To Send
		MulticastTrackerData(s, remote);
	}

	closesocket(s);
	WSACleanup();
}

//Decode with Mavlink Protocal
void LayserServer::DecodeMavlink(uint8_t channel, char * data, int len)
{
	for (int i = 0; i < len; i++) {
		if (mavlink_parse_char(channel, data[i], &DecodeMsg[channel], &status)) {
			if (DecodeMsg[channel].msgid == MAVLINK_MSG_ID_ATTITUDE_QUATERNION)
			{
				memcpy(&pck, DecodeMsg[channel].payload64, MAVLINK_MSG_ID_ATTITUDE_QUATERNION_LEN + 5);
#ifdef MDebug
				printf("%d | %f | %f | %f | %s\n", pck.time_boot_ms, pck.pitchspeed, pck.rollspeed, pck.yawspeed, pck.name);
#endif
				ReadTracker[channel].timeStemp = pck.time_boot_ms;
				ReadTracker[channel].Qw = pck.q1;
				ReadTracker[channel].Qx = pck.q2;
				ReadTracker[channel].Qy = pck.q3;
				ReadTracker[channel].Qz = pck.q4;
			}
		}
	}
}

//Encode with Mavlink And BroadCast
void LayserServer::MulticastTrackerData(SOCKET &s, sockaddr_in &remote)
{
	EnterCriticalSection(&g_cs);// stupid?

	map<char*, int>::iterator it = IpMapGenID.begin();
	Trackers->clear();

	int n = 0;
	while (it != IpMapGenID.end()) {
		
		int genId = it->second;
		//check zombie ip
		double curTime = GetTickCount();
		double timeSpan = curTime - GenIDMapTimeTick[genId];
		if (timeSpan > IP_TIME_OUT) {
			
			IpMapGenID.erase(it++);
			
			DelID(genId);
			GenIDMapReadID[genId] = -1;
		}
		else {// not time out
			//update Trackers
			Tracker* curTracker = &ReadTracker[genId];
			int realId = GenIDMapReadID[genId];
			curTracker->ReadId = realId;
			Trackers->push_back(curTracker);
			
			n++;
			it++;
		}
	}

	LeaveCriticalSection(&g_cs);


	for (int i = 0; i < Trackers->size(); i++) {
		//mavlink multicast  thread lock require?
		Tracker* curTracker = (*Trackers)[i];
		int realId = curTracker->ReadId;
		ToSendTracker.ID = realId;
		ToSendTracker.Qw = curTracker->Qw;
		ToSendTracker.Qx = curTracker->Qx;
		ToSendTracker.Qy = curTracker->Qy;
		ToSendTracker.Qz = curTracker->Qz;

		mavlink_msg_t_tracker_encode(1, 200, &EncodeMsg[realId], &ToSendTracker);
		int mavLen = mavlink_msg_to_send_buffer(MavSendBuffer[realId], &EncodeMsg[realId]);

		//printf("%d %d\n", n, realId);
		if (sendto(s, (char*)MavSendBuffer[realId], mavLen, 0, (sockaddr*)&remote, sizeof(remote)) < 0) {
			perror("sendto failed");
		}
	}
	
}

void LayserServer::InitID()
{
	for (int i = 1; i < MAX_TRACKER_NUM; i++) {
		NextGenID[i] = i + 1;
	}
	NextGenID[MAX_TRACKER_NUM] = 0; //end
	NextGenID[0] = 1;//as tail manager

	for (int i = 0; i <= MAX_TRACKER_NUM; i++) {
		GenIDMapReadID[i] = -1;
		IsGenIDExist[i] = false;
	}
}

int LayserServer::GenID()
{
	int i = NextGenID[0];
	if (i != 0) {
		IsGenIDExist[i] = true;
		NextGenID[0] = NextGenID[i];
	}
	return i;
}

int LayserServer::DelID(int id)
{
	if (id >= 1 && id <= MAX_TRACKER_NUM && IsGenIDExist[id]) {
		
		int i = NextGenID[0];
		NextGenID[0] = id;
		NextGenID[id] = i;
		IsGenIDExist[id] = false;
		return 0;
	}
	return -1;
}



